import '../../attribute_format.dart';
import '../../enums.dart';
import '_generate_mvvm_repository_impl_template.dart';
import '_generate_mvvm_repository_template.dart';
import '_generate_mvvm_usecase_template.dart';
import '_generate_mvvm_model_template.dart';

class MvvmArchitectureTemplateGenerator {

  static final MvvmArchitectureTemplateGenerator instance = MvvmArchitectureTemplateGenerator._internal();
  const MvvmArchitectureTemplateGenerator._internal();

  /// Generates a MVVM model template for a given [feature].
  ///
  /// The generated model class will extend [Entity] and override the [toJson] and [copyWith] methods.
  ///
  /// If [attributes] is not empty, it is used to generate the fields of the model.
  /// Otherwise, an empty model is generated.
  String mvvmModelTemplate({required String feature, List<AttributeFormat> attributes = const []}) 
    => generateMvvmModelTemplate(feature: feature, attributes: attributes);

  /// Generates a MVVM repository template for a given [feature].
  ///
  /// The generated class is an abstract class that contains one abstract method
  /// for each usecase in [usecases].
  ///
  /// Each method has the same name as the usecase and takes as arguments the
  /// attributes of the usecase. The return type of the method is [Future] or
  /// [Stream] depending on the value of [usecaseTypes[usecase]].
  ///
  /// The generated class is a valid implementation of
  /// [${CommonFunctions.instance.capitalize(feature)}Repository] and can be used as a
  /// starting point for implementing the repository for the feature.
  String mvvmRepositoryTemplate({
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
    required String feature,
  }) => generateMvvmRepositoryTemplate(feature: feature, usecases: usecases, usecaseAttributes: usecaseAttributes, usecaseTypes: usecaseTypes);

  /// Generates a MVVM repository implementation template.
  ///
  /// This function generates a class that implements the abstract repository class generated by
  /// [mvvmRepositoryTemplate].
  ///
  /// The generated class is a valid implementation of
  /// [${CommonFunctions.instance.capitalize(feature)}RepositoryImpl] and can be used as a
  /// starting point for implementing the repository for the feature.
  String mvvmRepositoryImplTemplate({
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
    required String feature,
  }) => generateMvvmRepositoryImplTemplate(usecases: usecases, usecaseTypes: usecaseTypes, usecaseAttributes: usecaseAttributes, feature: feature);

  /// Generates an MVVM use case template.
  ///
  /// This function creates a use case class for a specified [feature] using the provided [usecase],
  /// [usecaseType], and [attributes].
  ///
  /// - [usecase]: The name of the use case for which the use case class is created.
  /// - [usecaseType]: The type of the use case. It can be either [UseCaseType.simpleStream] or [UseCaseType.future].
  /// - [attributes]: A list of attributes that define the parameters of the use case. If empty, a default template is generated.
  /// - [feature]: The name of the feature for which the use case is created.
  ///
  /// Returns a string representing the MVVM use case template code.
  String mvvmUseCaseTemplate({
    required String usecase,
    required UseCaseType usecaseType,
    List<AttributeFormat> attributes = const [],
    required String feature,
  }) {
    // Check if attributes are empty and decide which template generation function to call.
    return attributes.isEmpty
        ? generateMvvmUseCaseTemplate(usecase: usecase, usecaseType: usecaseType, feature: feature)
        : generateMvvmUseCaseTemplateWithAttributes(usecase: usecase, usecaseType: usecaseType, attributes: attributes, feature: feature);
  }

}
