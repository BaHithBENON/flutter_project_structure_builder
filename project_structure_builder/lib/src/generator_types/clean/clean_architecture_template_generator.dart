import '../../attribute_format.dart';
import '../../enums.dart';
import '_generate_clean_data_source_impl_template.dart';
import '_generate_clean_data_source_template.dart';
import '_generate_clean_entity_template.dart';
import '_generate_clean_model_template.dart';
import '_generate_clean_repository_impl_template.dart';
import '_generate_clean_repository_template.dart';
import '_generate_clean_usecase_template.dart';

/// A class that provides methods to generate clean architecture templates.
///
/// This class provides the following methods to generate clean architecture
/// templates:
///
/// * [cleanEntityTemplate] generates a clean architecture entity template.
/// * [cleanModelTemplate] generates a clean architecture model template.
/// * [cleanDataSourceTemplate] generates a clean architecture data source template.
/// * [cleanDataSourceImplTemplate] generates a clean architecture data source
///   implementation template.
/// * [cleanRepositoryTemplate] generates a clean architecture repository template.
/// * [cleanRepositoryImplTemplate] generates a clean architecture repository
///   implementation template.
/// * [cleanUseCaseTemplate] generates a clean architecture use case template.
class CleanArchitectureTemplateGenerator {

  // Singleton
  static final CleanArchitectureTemplateGenerator instance = CleanArchitectureTemplateGenerator._internal();
  const CleanArchitectureTemplateGenerator._internal();

  /// Generates a clean architecture entity template.
  ///
  /// This function utilizes [generateCleanEntityTemplate] to create an entity
  /// class for a specified [feature] using the provided [attributes].
  ///
  /// [feature] is the name of the feature for which the entity is created.
  /// [attributes] is a list of attributes that define the fields of the entity.
  String cleanEntityTemplate({required String feature, List<AttributeFormat> attributes = const []}) 
    => generateCleanEntityTemplate(feature: feature, attributes: attributes);

  /// Generates a clean architecture model template.
  ///
  /// This function utilizes [generateCleanModelTemplate] to create a model
  /// class for a specified [feature] using the provided [attributes].
  ///
  /// [feature] is the name of the feature for which the model is created.
  /// [attributes] is a list of attributes that define the fields of the model.
  /// [featuresStrategy] is the strategy to use for generating the feature.
  String cleanModelTemplate({required String feature, List<AttributeFormat> attributes = const [], required FeaturesStrategy featuresStrategy,}) 
    => generateCleanModelTemplate(feature: feature, attributes: attributes, featuresStrategy: featuresStrategy);

  /// Generates a clean architecture data source template.
  ///
  /// This function utilizes [generateCleanDataSourceTemplate] to create an
  /// abstract data source class for a specified [feature] using the provided
  /// [usecases], [usecaseTypes], and [usecaseAttributes].
  ///
  /// [feature] is the name of the feature for which the data source is created.
  /// [usecases] is a list of use cases that define the methods of the data source.
  /// [usecaseTypes] is a map where the keys are the names of the usecases and the
  /// values are the types of the usecases. The type of a usecase is either
  /// [UseCaseType.simpleStream] or [UseCaseType.future].
  /// [usecaseAttributes] is a map where the keys are the names of the usecases and
  /// the values are lists of attributes that define the parameters of the usecase.
  String cleanDataSourceTemplate({
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
    required String feature,
  }) => generateCleanDataSourceTemplate(feature: feature, usecases: usecases, usecaseAttributes: usecaseAttributes, usecaseTypes: usecaseTypes);
  
  /// Generates a clean architecture data source implementation template.
  ///
  /// This function utilizes [generateCleanDataSourceImplTemplate] to create a
  /// class that implements the abstract data source class generated by
  /// [cleanDataSourceTemplate].
  ///
  /// The generated class is a valid implementation of the data source for the
  /// specified [feature] using the provided [usecases], [usecaseTypes], and
  /// [usecaseAttributes].
  ///
  /// [feature] is the name of the feature for which the data source is created.
  /// [usecases] is a list of use cases that define the methods of the data source.
  /// [usecaseTypes] is a map where the keys are the names of the usecases and the
  /// values are the types of the usecases. The type of a usecase is either
  /// [UseCaseType.simpleStream] or [UseCaseType.future].
  /// [usecaseAttributes] is a map where the keys are the names of the usecases and
  /// the values are lists of attributes that define the parameters of the usecase.
  String cleanDataSourceImplTemplate({
    required String feature,
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
  }) => generateCleanDataSourceImplTemplate(
        feature: feature,
        usecases: usecases,
        usecaseAttributes: usecaseAttributes,
        usecaseTypes: usecaseTypes,
      );

  /// Generates a clean architecture repository template.
  ///
  /// This function utilizes [generateCleanRepositoryTemplate] to create an
  /// abstract repository class for a specified [feature] using the provided
  /// [usecases], [usecaseTypes], and [usecaseAttributes].
  ///
  /// [feature] is the name of the feature for which the repository is created.
  /// [usecases] is a list of use cases that define the methods of the repository.
  /// [usecaseTypes] is a map where the keys are the names of the usecases and the
  /// values are the types of the usecases. The type of a usecase is either
  /// [UseCaseType.simpleStream] or [UseCaseType.future].
  /// [usecaseAttributes] is a map where the keys are the names of the usecases and
  /// the values are lists of attributes that define the parameters of the usecase.
  /// [featuresStrategy] is the strategy to use for generating the feature.
  String cleanRepositoryTemplate({
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
    required String feature,
    required FeaturesStrategy featuresStrategy,
  }) => generateCleanRepositoryTemplate(
        usecases: usecases,
        usecaseTypes: usecaseTypes,
        usecaseAttributes: usecaseAttributes,
        feature: feature,
        featuresStrategy: featuresStrategy,
      );

  /// Generates a clean architecture repository implementation template.
  ///
  /// This function utilizes [generateCleanRepositoryImplTemplate] to create a
  /// class that implements the abstract repository class generated by
  /// `cleanRepositoryTemplate`.
  ///
  /// The generated class is a valid implementation of the repository for the
  /// specified [feature] using the provided [usecases], [usecaseTypes], and
  /// [usecaseAttributes].
  ///
  /// [feature] is the name of the feature for which the repository is created.
  /// [usecases] is a list of use cases that define the methods of the repository.
  /// [usecaseTypes] is a map where the keys are the names of the usecases and the
  /// values are the types of the usecases. The type of a usecase is either
  /// [UseCaseType.simpleStream] or [UseCaseType.future].
  /// [usecaseAttributes] is a map where the keys are the names of the usecases and
  /// the values are lists of attributes that define the parameters of the usecase.
  /// [featuresStrategy] is the strategy to use for generating the feature.
  String cleanRepositoryImplTemplate({
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
    required String feature,
    required FeaturesStrategy featuresStrategy,
  }) => generateCleanRepositoryImplTemplate(
        usecases: usecases,
        usecaseTypes: usecaseTypes,
        usecaseAttributes: usecaseAttributes,
        feature: feature,
        featuresStrategy: featuresStrategy,
      );
  
  /// Generates a clean architecture use case template.
  ///
  /// This function utilizes [generateCleanUseCaseTemplate] to create a use case
  /// class for a specified [feature] using the provided [usecase], [usecaseType],
  /// and [attributes].
  ///
  /// [usecase] is the name of the use case for which the use case class is created.
  /// [usecaseType] is the type of the usecase. The type of a usecase is either
  /// [UseCaseType.simpleStream] or [UseCaseType.future].
  /// [attributes] is a list of attributes that define the parameters of the usecase.
  /// [feature] is the name of the feature for which the use case is created.
  /// [featuresStrategy] is the strategy to use for generating the feature.
  String cleanUseCaseTemplate({
    required String usecase, required UseCaseType usecaseType, List<AttributeFormat> attributes = const [],
    required String feature, required FeaturesStrategy featuresStrategy,
  }) => attributes.isEmpty ? generateCleanUseCaseTemplate(usecase: usecase, usecaseType: usecaseType, feature: feature, featuresStrategy: featuresStrategy) 
    : generateCleanUseCaseTemplateWithAttributes(usecase: usecase, usecaseType: usecaseType, attributes: attributes, feature: feature, featuresStrategy: featuresStrategy);

}
