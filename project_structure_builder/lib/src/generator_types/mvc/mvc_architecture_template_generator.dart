import '../../attribute_format.dart';
import '../../enums.dart';
import '_generate_mvc_repository_impl_template.dart';
import '_generate_mvc_repository_template.dart';
import '_generate_mvc_usecase_template.dart';
import '_generate_mvc_model_template.dart';

/// A generator for MVC architecture templates.
///
/// This class provides methods to generate various components of the MVC architecture
/// for a specified feature. It includes methods to generate model, repository, 
/// repository implementation, and use case templates.
class MvcArchitectureTemplateGenerator {

  static final MvcArchitectureTemplateGenerator instance = MvcArchitectureTemplateGenerator._internal();
  const MvcArchitectureTemplateGenerator._internal();

  /// Generates a mvc model template for a given [feature].
  /// 
  /// If [attributes] is not empty, it is used to generate the fields of the model.
  /// Otherwise, an empty model is generated.
  /// 
  /// The generated model extends [Entity] and overrides the [toJson] and [copyWith] methods
  String mvcModelTemplate({required String feature, List<AttributeFormat> attributes = const []}) 
    => generateMvcModelTemplate(feature: feature, attributes: attributes);

  /// Generates a mvc repository template for a given [feature].
  /// 
  /// The generated repository contains one abstract method for each usecase in [usecases].
  /// Each method has the same name as the usecase and takes as arguments the
  /// attributes of the usecase. The return type of the method is [Future] or
  /// [Stream] depending on the value of [usecaseTypes[usecase]].
  /// 
  /// The generated class is a valid implementation of
  /// [${CommonFunctions.instance.capitalize(feature)}Repository] and can be used as a
  /// starting point for implementing the repository for the feature.
  String mvcRepositoryTemplate({
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
    required String feature,
  }) => generateMvcRepositoryTemplate(feature: feature, usecases: usecases, usecaseAttributes: usecaseAttributes, usecaseTypes: usecaseTypes);

  /// Generates a mvc repository implementation template.
  ///
  /// The generated class implements the abstract repository class generated by
  /// [mvcRepositoryTemplate].
  ///
  /// The generated class is a valid implementation of
  /// [${CommonFunctions.instance.capitalize(feature)}Repository] and can be used as a
  /// starting point for implementing the repository for the feature.
  String mvcRepositoryImplTemplate({
    required List<String> usecases,
    required Map<String, UseCaseType> usecaseTypes,
    required Map<String, List<AttributeFormat>> usecaseAttributes,
    required String feature,
  }) => generateMvcRepositoryImplTemplate(
    usecases: usecases,
    usecaseTypes: usecaseTypes,
    usecaseAttributes: usecaseAttributes,
    feature: feature,
  );

  /// Generates a MVC use case template.
  ///
  /// This function generates a use case class for a specified [feature] using the provided [usecase],
  /// [usecaseType], and [attributes].
  ///
  /// - [usecase]: The name of the use case for which the use case class is created.
  /// - [usecaseType]: The type of the use case. It can be either [UseCaseType.simpleStream] or [UseCaseType.future].
  /// - [attributes]: A list of attributes that define the parameters of the use case. If empty, a default template is generated.
  /// - [feature]: The name of the feature for which the use case is created.
  ///
  /// Returns a string representing the MVC use case template code.
  String mvcUseCaseTemplate({
    required String usecase, 
    required UseCaseType usecaseType, 
    List<AttributeFormat> attributes = const [],
    required String feature
  }) {
    // Check if attributes are empty and decide which template generation function to call.
    return attributes.isEmpty 
      ? generateMvcUseCaseTemplate(usecase: usecase, usecaseType: usecaseType, feature: feature) 
      : generateMvcUseCaseTemplateWithAttributes(usecase: usecase, usecaseType: usecaseType, attributes: attributes, feature: feature);
  }

}
